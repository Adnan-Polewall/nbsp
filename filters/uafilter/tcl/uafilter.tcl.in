#!%TCLSH%
#
# $Id$
#

## The common defaults
set filters_init_file "/usr/local/libexec/nbsp/filters.init";
if {[file exists $filters_init_file] == 0} {
    puts "uafilter disabled: $filters_init_file not found.";
    return 1;
}
source $filters_init_file;
unset filters_init_file;

if {$filters_init_status == 1} {
	return 1;
}
unset filters_init_status;

# packages
package require nbsputil;

set ua_init_file [file join $common(libdir) "uafilter.init"];
if {[file exists $ua_init_file] == 0} {
	log_msg "uafilter disabled: $ua_init_file not found.";
	return 1;
}
source $ua_init_file;
unset ua_init_file;

#
# Functions
#
proc main {argc argv} {

    global uafilter;
    global errorInfo;

    # The upperair data directory must exist
    if {[file isdirectory $uafilter(datadir)] == 0} {
	log_msg "$uafilter(datadir) does not exist.";
	return 1;
    }

    cd $uafilter(datadir);
	
    # gets returns -1 on eof. In addition the server explicitly
    # signals the filters to quit by sending a blankline
    # (gets returns 0 in this case, and finfo is "").

    while {[gets stdin finfo] >= 0} {
	if {$finfo == ""} {
	    log_msg "Received request to quit.";
	    break;
	}

	set status [catch {process $finfo} errmsg];
	if {$status == 1} {
	    log_msg "Error processing $finfo";
	    log_msg $errmsg;
	    log_msg $errorInfo;
	}
    }
}

proc process {finfo} {

    global uafilter;

    filterlib_get_rcvars rc $finfo -nobody;

    if {[regexp $uafilter(regex) $rc(fname)] == 0} {
	return;
    }

    set status [catch {
        save_rawdata rc;
    } errmsg];

    if {$status != 0} {
	log_msg $errmsg;
    }
}

proc save_rawdata {rc_name} {

    upvar $rc_name rc;
    global uafilter;

    set fpath $rc(fpath);
    set wmotime $rc(wmotime);

    set rawdata [exec nbspfm35d -s $uafilter(FS) $fpath];

    if {$rawdata eq ""} {
	# nbspfm35d returns an empty string if the file does not contain
	# a valid report.
	return;
    }

    # Extract the data and save it in the daily/hourly archives.
    if {$uafilter(daily_arcv_enable) == 1} {
	save_data_daily_arcv $wmotime $rawdata;
    }

    if {$uafilter(hourly_arcv_enable) == 1} {
	save_data_hourly_arcv $wmotime $rawdata;
    }

    # Call the post (user) filter if it is has been defined.
    if {[file executable $uafilter(postfilter)]} {
	set status [catch {
	    set F [open "|$uafilter(postfilter)" w];
	    puts $F $rawdata;
	} errmsg];

	if {[info exists F]} {
	    close $F;
	}

	if {$status != 0} {
	    log_msg $errmsg;
	}
    }
}

proc save_data_daily_arcv {wmotime rawdata} {

    global uafilter;

    set seconds [::nbsputil::date::clock_seconds $wmotime];
    set ymd [clock format $seconds -gmt true -format "%Y%m%d"];

    set rawdata_list [split $rawdata "\n"];
    foreach data $rawdata_list {
  	set data_parts [split $data $uafilter(FS)];
        set station [lindex $data_parts 2];
	set arcvfname ${station}_${ymd};
	append arcvfname $uafilter(arcv_fext);

	set savesubdir [file join $uafilter(arcv_dir) $ymd \
	    $uafilter(daily_arcv_datadir)];
	file mkdir $savesubdir;

	set arcvfile [file join $savesubdir $arcvfname];
	filterlib_file_append $arcvfile $data;
    }
}

proc save_data_hourly_arcv {wmotime rawdata} {

    global uafilter;

    set seconds [::nbsputil::date::clock_seconds $wmotime];
    set ymd [clock format $seconds -gmt true -format "%Y%m%d"];
    set ymdh [clock format $seconds -gmt true -format "%Y%m%d%H"];
  
    set arcvfname $ymdh;
    append arcvfname $uafilter(arcv_fext);

    set savesubdir [file join $uafilter(arcv_dir) $ymd \
	$uafilter(hourly_arcv_datadir)];
    file mkdir $savesubdir;

    set arcvfile [file join $savesubdir $arcvfname];
    filterlib_file_append $arcvfile $rawdata;
}

filterlib_init;		# open the cpool if enabled
main $argc $argv;
filterlib_end;		# close the cpool if enabled
