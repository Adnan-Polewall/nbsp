#!%TCLSH%
#
# $Id$
#
# Open any number of filters in any number of remote hosts.
#

## The common defaults
set filters_init_file "/usr/local/libexec/nbsp/filters.init";
if {[file exists $filters_init_file] == 0} {
    puts "rmtfilter disabled: $filters_init_file not found.";
    return 1;
}
source $filters_init_file;
unset filters_init_file;

if {$filters_init_status == 1} {
    return 1;
}
unset filters_init_status;

#
# packages
#
## package require nbsp::util;

#
# For testing
#
## set common(libdir) ".";
## set common(confdir) ".";
## set common(localconfdirs) [list site];

set _init_file [file join $common(libdir) "rmtfilter.init"];
if {[file exists $_init_file] == 0} {
    log_msg "rmtfilter disabled: $rmt_init_file not found.";
    return 1;
}
source $_init_file;
unset _init_file;

#
# Functions
#

proc rmtfilter_open_filter {node filter_name} {

    global rmtfilter;

    set filter_path $rmtfilter(filter_path,$node,$filter_name);

    set cmd [join [concat "|ssh" $rmtfilter(sshopts,$node,$filter_name) \
		       $node $filter_path] " "];

    set status [catch {
	set F [open $cmd w];
	fconfigure $F -buffering line -encoding binary -translation binary;
    } errmsg];

    if {$status == 0} {
	set rmtfilter(F,$node,$filter_name) $F;
	log_msg "Opened $node:$filter_name";
    } else {
	log_errc "Could not open $node:$filter_name. $errmsg";
    }

    return $status;
}

proc rmtfilter_close_filter {node filter_name} {
    
    global rmtfilter;

    set status 0;

    if {[info exists rmtfilter(F,$node,$filter_name)]} {
	set status [catch {close $rmtfilter(F,$node,$filter_name)} errmsg];
	unset rmtfilter(F,$node,$filter_name);
    }

    if {$status != 0} {
	log_errc $errmsg;
    } else {
	log_msg "Closed $node:$filter_name";
    }
}

proc rmtfilter_isopen_filter {node filter_name} {

    global rmtfilter;

    if {[info exists rmtfilter(F,$node,$filter_name)]} {
	return 1;
    } else {
	return 0;
    }
}

proc rmtfilter_writeto_filter {node filter_name data} {

    global rmtfilter;

    if {[rmtfilter_isopen_filter $node $filter_name] == 0} {
	rmtfilter_open_filter $node $filter_name;
    }

    if {[rmtfilter_isopen_filter $node $filter_name] == 0} {
	return 1;
    }

    set status [catch {
	puts $rmtfilter(F,$node,$filter_name) $data;
    } errmsg];

    if {$status != 0} {
	rmtfilter_close_filter $node $filter_name;
	log_errc "Could not write to $node:$filter_name. $errmsg";
    }

    return $status;
}

proc rmtfilter_remove_filter {node filter_name} {

    global rmtfilter;

    set filter_path $rmtfilter(filter_path,$node,$filter_name);

    set i [lsearch -exact $rmtfilter(filter_listn,$node) $filter_name];
    if {$i != -1} {
	set $rmtfilter(filter_listn,$node) \
	    [lreplace $rmtfilter(filter_listn,$node) $i $i];
    }

    set i [lsearch -exact $rmtfilter(filter_listp,$node) $filter_path];
    if {$i != -1} {
	set $rmtfilter(filter_listp,$node) \
	    [lreplace $rmtfilter(filter_listp,$node) $i $i];
    }

    set rmtfilter(masterlist) [list];
    foreach node $rmtfilter(nodes) {
	foreach filter_name $rmtfilter(filter_listn,$node) {
    	    set filter_path $rmtfilter(filter_path,$node,$filter_name);
	    
            lappend rmtfilter(masterlist)\
		[list $node $filter_name $filter_path];
	}
    }
}

proc rmtfilter_open_all_filters {} {

    global rmtfilter;

    foreach entry $rmtfilter(masterlist) {
	set node [lindex $entry 0];
	set filter_name [lindex $entry 1];
	set filter_path $rmtfilter(filter_path,$node,$filter_name);
	set status [rmtfilter_open_filter $node $filter_name];
	if {$status != 0} {
	    rmtfilter_remove_filter $node $filter_path;
	    log_msg "Removed $node:$filter_name";
	}
    }
}

proc rmtfilter_close_all_filters {} {

    global rmtfilter;

    foreach entry $rmtfilter(masterlist) {
	set node [lindex $entry 0];
	set filter_name [lindex $entry 1];
	set filter_path $rmtfilter(filter_path,$node,$filter_name);
	rmtfilter_close_filter $node $filter_name;
    }
}

proc main {argc argv} {

    global errorInfo;
    while {[gets stdin finfo] >= 0} {
        if {$finfo == ""} {
            log_msg "Received request to quit.";
            break;
        }

        set status [catch {process $finfo} errmsg];
        if {$status == 1} {
            log_msg "Error processing $finfo";
            log_msg $errmsg;
            log_msg $errorInfo;
        }
    }
}

proc process {finfo} {

    global rmtfilter;

    # Since we need only the fname, bypass this call
    #
    # filterlib_get_rcvars rc $finfo -nobody;
    #
    # and instead do it explicitly

    set rc(fname) [lindex [split $finfo] 5];

    foreach entry $rmtfilter(masterlist) {
	set node [lindex $entry 0];
	set filter_name [lindex $entry 1];

	if {[filterlib_uwildmat \
	    $rmtfilter(fname_uregex,$node,$filter_name) $rc(fname)] == 0} {
	    continue;
	}

	set status [rmtfilter_writeto_filter $node $filter_name $finfo];
	if {$status != 0} {
	    # Retry
	    set status [rmtfilter_writeto_filter $node $filter_name $finfo];
	    if {$status == 0} {
		log_msg "Retrying suceeded writing to $node:$filter_name";
	    }
	}
    }
}

#
# main
#
rmtfilter_open_all_filters;
main $argc $argv
rmtfilter_close_all_filters;
